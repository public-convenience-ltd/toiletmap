-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.

-- Extension: supa_audit

-- SPDX-License-Identifier: Apache-2.0
/*
    Generic Audit Trigger
    Linear Time Record Version History

    Date:
        2022-02-03

    Purpose:
        Generic audit history for tables including an indentifier
        to enable indexed linear time lookup of a primary key's version history
*/


-- Namespace to "audit"
create schema if not exists audit;


-- Create enum type for SQL operations to reduce disk/memory usage vs text
create type audit.operation as enum (
    'INSERT',
    'UPDATE',
    'DELETE',
    'TRUNCATE'
);


create table audit.record_version(
    -- unique auto-incrementing id
    id             bigserial primary key,
    -- uniquely identifies a record by primary key [primary key + table_oid]
    record_id      uuid,
    -- uniquely identifies a record before update/delete
    old_record_id  uuid,
    -- INSERT/UPDATE/DELETE/TRUNCATE/SNAPSHOT
    op             audit.operation not null,
    ts             timestamptz not null default (now()),
    table_oid      oid not null,
    table_schema   name not null,
    table_name     name not null,

    -- contents of the record
    record         jsonb,
    -- previous record contents for UPDATE/DELETE
    old_record     jsonb,

    -- at least one of record_id or old_record_id is populated, except for truncates
    check (coalesce(record_id, old_record_id) is not null or op = 'TRUNCATE'),

    -- record_id must be populated for insert and update
    check (op in ('INSERT', 'UPDATE') = (record_id is not null)),
    check (op in ('INSERT', 'UPDATE') = (record is not null)),

    -- old_record must be populated for update and delete
    check (op in ('UPDATE', 'DELETE') = (old_record_id is not null)),
    check (op in ('UPDATE', 'DELETE') = (old_record is not null))
);

do $$
    begin
        -- Detect if we're in a supabase project
        -- Ensure `auth.uid() -> uuid` and `auth.role() -> text` exist
        if (
            select
                count(distinct f.proname) = 2
            from
                pg_proc f
                join pg_namespace nsp
                    on f.pronamespace = nsp.oid
                join pg_type pt
                    on f.prorettype = pt.oid
            where
                (nsp.nspname, f.proname, pt.typname) in (
                    ('auth', 'uid',  'uuid'),
                    ('auth', 'role', 'text')
                )
                and f.pronargs = 0
            )
            then

            alter table audit.record_version add column auth_uid  uuid default (auth.uid());
            alter table audit.record_version add column auth_role text default (auth.role());
        end if;
    end
$$;


create index record_version_record_id
    on audit.record_version(record_id)
    where record_id is not null;


create index record_version_old_record_id
    on audit.record_version(old_record_id)
    where old_record_id is not null;


create index record_version_ts
    on audit.record_version
    using brin(ts);


create index record_version_table_oid
    on audit.record_version(table_oid);


create or replace function audit.primary_key_columns(entity_oid oid)
    returns text[]
    stable
    security definer
    set search_path = ''
    language sql
as $$
    -- Looks up the names of a table's primary key columns
    select
        coalesce(
            array_agg(pa.attname::text order by pa.attnum),
            array[]::text[]
        ) column_names
    from
        pg_index pi
        join pg_attribute pa
            on pi.indrelid = pa.attrelid
            and pa.attnum = any(pi.indkey)

    where
        indrelid = $1
        and indisprimary
$$;


create or replace function audit.to_record_id(entity_oid oid, pkey_cols text[], rec jsonb)
    returns uuid
    stable
    language sql
as $$
    select
        case
            when rec is null then null
            when pkey_cols = array[]::text[] then extensions.uuid_generate_v4()
            else (
                select
                    uuid_generate_v5(
                        'fd62bc3d-8d6e-43c2-919c-802ba3762271',
                        ( jsonb_build_array(to_jsonb($1)) || jsonb_agg($3 ->> key_) )::text
                    )
                from
                    unnest($2) x(key_)
            )
        end
$$;


create or replace function audit.insert_update_delete_trigger()
    returns trigger
    security definer
    -- can not use search_path = '' here because audit.to_record_id requires
    -- uuid_generate_v4, which may be installed in a user-defined schema
    language plpgsql
as $$
declare
    pkey_cols text[] = audit.primary_key_columns(TG_RELID);

    record_jsonb jsonb = to_jsonb(new);
    record_id uuid = audit.to_record_id(TG_RELID, pkey_cols, record_jsonb);

    old_record_jsonb jsonb = to_jsonb(old);
    old_record_id uuid = audit.to_record_id(TG_RELID, pkey_cols, old_record_jsonb);
begin

    insert into audit.record_version(
        record_id,
        old_record_id,
        op,
        table_oid,
        table_schema,
        table_name,
        record,
        old_record
    )
    select
        record_id,
        old_record_id,
        TG_OP::audit.operation,
        TG_RELID,
        TG_TABLE_SCHEMA,
        TG_TABLE_NAME,
        record_jsonb,
        old_record_jsonb;

    return coalesce(new, old);
end;
$$;


create or replace function audit.truncate_trigger()
    returns trigger
    security definer
    set search_path = ''
    language plpgsql
as $$
begin
    insert into audit.record_version(
        op,
        table_oid,
        table_schema,
        table_name
    )
    select
        TG_OP::audit.operation,
        TG_RELID,
        TG_TABLE_SCHEMA,
        TG_TABLE_NAME;

    return coalesce(old, new);
end;
$$;


create or replace function audit.enable_tracking(regclass)
    returns void
    volatile
    security definer
    set search_path = ''
    language plpgsql
as $$
declare
    statement_row text = format('
        create trigger audit_i_u_d
            after insert or update or delete
            on %s
            for each row
            execute procedure audit.insert_update_delete_trigger();',
        $1
    );

    statement_stmt text = format('
        create trigger audit_t
            after truncate
            on %s
            for each statement
            execute procedure audit.truncate_trigger();',
        $1
    );

    pkey_cols text[] = audit.primary_key_columns($1);
begin
    if pkey_cols = array[]::text[] then
        raise exception 'Table % can not be audited because it has no primary key', $1;
    end if;

    if not exists(select 1 from pg_trigger where tgrelid = $1 and tgname = 'audit_i_u_d') then
        execute statement_row;
    end if;

    if not exists(select 1 from pg_trigger where tgrelid = $1 and tgname = 'audit_t') then
        execute statement_stmt;
    end if;
end;
$$;


create or replace function audit.disable_tracking(regclass)
    returns void
    volatile
    security definer
    set search_path = ''
    language plpgsql
as $$
declare
    statement_row text = format(
        'drop trigger if exists audit_i_u_d on %s;',
        $1
    );

    statement_stmt text = format(
        'drop trigger if exists audit_t on %s;',
        $1
    );
begin
    execute statement_row;
    execute statement_stmt;
end;
$$;

-- Extension: postgis

-- DROP EXTENSION postgis;

CREATE EXTENSION IF NOT EXISTS postgis
    SCHEMA public
    VERSION '3.1.4';

CREATE OR REPLACE FUNCTION audit.to_record_id(
	entity_oid oid,
	pkey_cols text[],
	rec jsonb)
    RETURNS uuid
    LANGUAGE 'sql'
    COST 100
    STABLE PARALLEL UNSAFE
AS $BODY$
    select
        case
            when rec is null then null
            when pkey_cols = array[]::text[] then extensions.uuid_generate_v4()
            else (
                select
                    extensions.uuid_generate_v5(
                        'fd62bc3d-8d6e-43c2-919c-802ba3762271',
                        ( jsonb_build_array(to_jsonb($1)) || jsonb_agg($3 ->> key_) )::text
                    )
                from
                    unnest($2) x(key_)
            )
        end
$BODY$;

ALTER FUNCTION audit.to_record_id(oid, text[], jsonb)
    OWNER TO postgres;

CREATE OR REPLACE FUNCTION audit.enable_tracking(
	regclass)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE SECURITY DEFINER PARALLEL UNSAFE
    SET search_path=''
AS $BODY$
declare
    statement_row text = format('
        create trigger audit_i_u_d
            after insert or update or delete
            on %s
            for each row
            execute procedure audit.insert_update_delete_trigger();',
        $1
    );

    statement_stmt text = format('
        create trigger audit_t
            after truncate
            on %s
            for each statement
            execute procedure audit.truncate_trigger();',
        $1
    );

    pkey_cols text[] = audit.primary_key_columns($1);
begin
    if pkey_cols = array[]::text[] then
        raise exception 'Table % can not be audited because it has no primary key', $1;
    end if;

    if not exists(select 1 from pg_trigger where tgrelid = $1 and tgname = 'audit_i_u_d') then
        execute statement_row;
    end if;

    if not exists(select 1 from pg_trigger where tgrelid = $1 and tgname = 'audit_t') then
        execute statement_stmt;
    end if;
end;
$BODY$;

ALTER FUNCTION audit.enable_tracking(regclass)
    OWNER TO postgres;

CREATE OR REPLACE FUNCTION audit.disable_tracking(
	regclass)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE SECURITY DEFINER PARALLEL UNSAFE
    SET search_path=''
AS $BODY$
declare
    statement_row text = format(
        'drop trigger if exists audit_i_u_d on %s;',
        $1
    );

    statement_stmt text = format(
        'drop trigger if exists audit_t on %s;',
        $1
    );
begin
    execute statement_row;
    execute statement_stmt;
end;
$BODY$;

ALTER FUNCTION audit.disable_tracking(regclass)
    OWNER TO postgres;

CREATE OR REPLACE FUNCTION audit.primary_key_columns(
	entity_oid oid)
    RETURNS text[]
    LANGUAGE 'sql'
    COST 100
    STABLE SECURITY DEFINER PARALLEL UNSAFE
    SET search_path=''
AS $BODY$
    -- Looks up the names of a table's primary key columns
    select
        coalesce(
            array_agg(pa.attname::text order by pa.attnum),
            array[]::text[]
        ) column_names
    from
        pg_index pi
        join pg_attribute pa
            on pi.indrelid = pa.attrelid
            and pa.attnum = any(pi.indkey)

    where
        indrelid = $1
        and indisprimary
$BODY$;

ALTER FUNCTION audit.primary_key_columns(oid)
    OWNER TO postgres;

CREATE OR REPLACE FUNCTION audit.insert_update_delete_trigger()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF SECURITY DEFINER
AS $BODY$
declare
    pkey_cols text[] = audit.primary_key_columns(TG_RELID);

    record_jsonb jsonb = to_jsonb(new);
    record_id uuid = audit.to_record_id(TG_RELID, pkey_cols, record_jsonb);

    old_record_jsonb jsonb = to_jsonb(old);
    old_record_id uuid = audit.to_record_id(TG_RELID, pkey_cols, old_record_jsonb);
begin

    insert into audit.record_version(
        record_id,
        old_record_id,
        op,
        table_oid,
        table_schema,
        table_name,
        record,
        old_record
    )
    select
        record_id,
        old_record_id,
        TG_OP::audit.operation,
        TG_RELID,
        TG_TABLE_SCHEMA,
        TG_TABLE_NAME,
        record_jsonb,
        old_record_jsonb;

    return coalesce(new, old);
end;
$BODY$;

ALTER FUNCTION audit.insert_update_delete_trigger()
    OWNER TO postgres;

CREATE OR REPLACE FUNCTION audit.truncate_trigger()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF SECURITY DEFINER
    SET search_path=''
AS $BODY$
begin
    insert into audit.record_version(
        op,
        table_oid,
        table_schema,
        table_name
    )
    select
        TG_OP::audit.operation,
        TG_RELID,
        TG_TABLE_SCHEMA,
        TG_TABLE_NAME;

    return coalesce(old, new);
end;
$BODY$;

ALTER FUNCTION audit.truncate_trigger()
    OWNER TO postgres;

CREATE TABLE IF NOT EXISTS audit.record_version
(
    id bigint NOT NULL DEFAULT nextval('audit.record_version_id_seq'::regclass),
    record_id uuid,
    old_record_id uuid,
    op audit.operation NOT NULL,
    ts timestamp with time zone NOT NULL DEFAULT now(),
    table_oid oid NOT NULL,
    table_schema name COLLATE pg_catalog."C" NOT NULL,
    table_name name COLLATE pg_catalog."C" NOT NULL,
    record jsonb,
    old_record jsonb,
    auth_uid uuid DEFAULT auth.uid(),
    auth_role text COLLATE pg_catalog."default" DEFAULT auth.role(),
    CONSTRAINT record_version_pkey PRIMARY KEY (id),
    CONSTRAINT record_version_check CHECK (COALESCE(record_id, old_record_id) IS NOT NULL OR op = 'TRUNCATE'::audit.operation),
    CONSTRAINT record_version_check1 CHECK ((op = ANY (ARRAY['INSERT'::audit.operation, 'UPDATE'::audit.operation])) = (record_id IS NOT NULL)),
    CONSTRAINT record_version_check2 CHECK ((op = ANY (ARRAY['INSERT'::audit.operation, 'UPDATE'::audit.operation])) = (record IS NOT NULL)),
    CONSTRAINT record_version_check3 CHECK ((op = ANY (ARRAY['UPDATE'::audit.operation, 'DELETE'::audit.operation])) = (old_record_id IS NOT NULL)),
    CONSTRAINT record_version_check4 CHECK ((op = ANY (ARRAY['UPDATE'::audit.operation, 'DELETE'::audit.operation])) = (old_record IS NOT NULL))
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS audit.record_version
    OWNER to postgres;
CREATE INDEX IF NOT EXISTS record_version_old_record_id
    ON audit.record_version USING btree
    (old_record_id ASC NULLS LAST)
    TABLESPACE pg_default
    WHERE old_record_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS record_version_record_id
    ON audit.record_version USING btree
    (record_id ASC NULLS LAST)
    TABLESPACE pg_default
    WHERE record_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS record_version_table_oid
    ON audit.record_version USING btree
    (table_oid ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS record_version_ts
    ON audit.record_version USING brin
    (ts)
    TABLESPACE pg_default;

-- Type: operation

-- DROP TYPE IF EXISTS audit.operation;

ALTER TYPE audit.operation
    OWNER TO postgres;

CREATE TABLE IF NOT EXISTS public.areas
(
    legacy_id character(24) COLLATE pg_catalog."default",
    geometry geography,
    name text COLLATE pg_catalog."default",
    priority integer,
    type text COLLATE pg_catalog."default",
    dataset_id integer,
    version integer,
    id integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    CONSTRAINT area_id PRIMARY KEY (id),
    CONSTRAINT area_name UNIQUE (name),
    CONSTRAINT legacy_area_id UNIQUE (legacy_id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.areas
    OWNER to postgres;

GRANT ALL ON TABLE public.areas TO authenticated;

GRANT ALL ON TABLE public.areas TO anon;

GRANT ALL ON TABLE public.areas TO service_role;

GRANT ALL ON TABLE public.areas TO postgres;

CREATE TRIGGER audit_i_u_d
    AFTER INSERT OR DELETE OR UPDATE
    ON public.areas
    FOR EACH ROW
    EXECUTE FUNCTION audit.insert_update_delete_trigger();

CREATE TRIGGER audit_t
    AFTER TRUNCATE
    ON public.areas
    FOR EACH STATEMENT
    EXECUTE FUNCTION audit.truncate_trigger();

CREATE TABLE IF NOT EXISTS public.toilets
(
    id character(24) DEFAULT md5(random()::text),
    created_at timestamptz,
    contributors text[] COLLATE pg_catalog."default",
    accessible boolean,
    active boolean,
    attended boolean,
    automatic boolean,
    baby_change boolean,
    men boolean,
    name text COLLATE pg_catalog."default",
    no_payment boolean,
    notes text COLLATE pg_catalog."default",
    payment_details text COLLATE pg_catalog."default",
    radar boolean,
    removal_reason text COLLATE pg_catalog."default",
    women boolean,
    updated_at timestamptz,
    geography geography,
    urinal_only boolean,
    all_gender boolean,
    children boolean,
    geohash text COLLATE pg_catalog."default" GENERATED ALWAYS AS (st_geohash(geography)) STORED,
    verified_at timestamptz,
    area_id integer,
    opening_times jsonb,
    location jsonb GENERATED ALWAYS AS (st_asgeojson((toilets.geography)::geometry)::jsonb) STORED,
    CONSTRAINT toilet_id PRIMARY KEY (id),
    CONSTRAINT toilets___area_id_fk FOREIGN KEY (area_id)
        REFERENCES public.areas (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.toilets
    OWNER to postgres;

GRANT ALL ON TABLE public.toilets TO authenticated;

GRANT ALL ON TABLE public.toilets TO anon;

GRANT ALL ON TABLE public.toilets TO service_role;

GRANT ALL ON TABLE public.toilets TO postgres;



CREATE TRIGGER audit_i_u_d
    AFTER INSERT OR DELETE OR UPDATE
    ON public.toilets
    FOR EACH ROW
    EXECUTE FUNCTION audit.insert_update_delete_trigger();

CREATE TRIGGER audit_t
    AFTER TRUNCATE
    ON public.toilets
    FOR EACH STATEMENT
    EXECUTE FUNCTION audit.truncate_trigger();
